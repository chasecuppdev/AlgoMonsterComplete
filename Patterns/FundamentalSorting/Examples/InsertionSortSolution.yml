MySolution:
  ComplexityAnalysis:
    Time: "O(n²)"
    Space: "O(1)"
    Stable: true
    InPlace: true
  
  Implementation: |
    for (int i = 1; i < list.Count; i++)
    {
        int current = i;
        // Move element backwards until it finds correct position
        while (current > 0 && list[current] < list[current - 1])
        {
            (list[current], list[current - 1]) = (list[current - 1], list[current]);
            current--;
        }
    }